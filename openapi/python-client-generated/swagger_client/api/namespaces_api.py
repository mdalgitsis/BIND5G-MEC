# coding: utf-8

"""
    Edge-API

    The Edge-API is built under the BIND5G project and its purpose is to act as an intermidiator between the NaaS API and the Kubernetes cluster. The NaaS API is a general API in respect of the project to remotely and automatically deploy, manage and control 5G and MEC infrastructures for a vast amount of experiments. On the other hand, the Edge-API is a specific backend API to manage Kubernetes resources and deploy application instances into the cluster.  # noqa: E501

    OpenAPI spec version: 1.0.2
    Contact: mdalgitsis@vicomtech.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class NamespacesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_namespace(self, body, **kwargs):  # noqa: E501
        """Create a Namespace  # noqa: E501

        Create a Namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespace(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Namespace body: Namespace object that contains the name to create a Namespace (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_namespace_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_namespace_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_namespace_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a Namespace  # noqa: E501

        Create a Namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespace_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Namespace body: Namespace object that contains the name to create a Namespace (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_namespace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_namespace`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_namespaced_deployment(self, body, namespace_name, **kwargs):  # noqa: E501
        """Create a Deployment in a specific namespace  # noqa: E501

        Create a namespaced Deployment Kubernetes-resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespaced_deployment(body, namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Deployment body: Deployment object that needs to be added to create a Deployment-resource in the cluster. **Note:** If you specify a limit for a resource, but do not specify any request, then Kubernetes copies the limit you specified and uses it as the requested value for the resource.  Also, replicas_number must be >= 1 and deployment_name must contain only lowercase alphanumeric characters or '-'. (required)
        :param str namespace_name: name of Namespace to create a Deployment (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_namespaced_deployment_with_http_info(body, namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_namespaced_deployment_with_http_info(body, namespace_name, **kwargs)  # noqa: E501
            return data

    def add_namespaced_deployment_with_http_info(self, body, namespace_name, **kwargs):  # noqa: E501
        """Create a Deployment in a specific namespace  # noqa: E501

        Create a namespaced Deployment Kubernetes-resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespaced_deployment_with_http_info(body, namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Deployment body: Deployment object that needs to be added to create a Deployment-resource in the cluster. **Note:** If you specify a limit for a resource, but do not specify any request, then Kubernetes copies the limit you specified and uses it as the requested value for the resource.  Also, replicas_number must be >= 1 and deployment_name must contain only lowercase alphanumeric characters or '-'. (required)
        :param str namespace_name: name of Namespace to create a Deployment (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_namespaced_deployment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_namespaced_deployment`")  # noqa: E501
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `add_namespaced_deployment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/deployments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_namespaced_limit_range(self, body, namespace_name, **kwargs):  # noqa: E501
        """Create a LimitRange in a specific namespace  # noqa: E501

        Create a namespaced LimitRange Kubernetes-resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespaced_limit_range(body, namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LimitRange body: LimitRanges pose default cpu and memory resource reservation in the specified namespaces. (required)
        :param str namespace_name: name of namespace to create a LimitRange (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_namespaced_limit_range_with_http_info(body, namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_namespaced_limit_range_with_http_info(body, namespace_name, **kwargs)  # noqa: E501
            return data

    def add_namespaced_limit_range_with_http_info(self, body, namespace_name, **kwargs):  # noqa: E501
        """Create a LimitRange in a specific namespace  # noqa: E501

        Create a namespaced LimitRange Kubernetes-resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespaced_limit_range_with_http_info(body, namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LimitRange body: LimitRanges pose default cpu and memory resource reservation in the specified namespaces. (required)
        :param str namespace_name: name of namespace to create a LimitRange (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_namespaced_limit_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_namespaced_limit_range`")  # noqa: E501
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `add_namespaced_limit_range`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/limitranges', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_namespaced_pod(self, body, namespace_name, **kwargs):  # noqa: E501
        """Create a Pod in a Namespace  # noqa: E501

        Create a Pod in a specific Namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespaced_pod(body, namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Pod body: Pod object that contains the key-value pairs to create a pod. **Note:** pod_name for good practices should contain only lowercase alphanumeric characters with or without '-' (required)
        :param str namespace_name: name of Namespace to create a Pod (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_namespaced_pod_with_http_info(body, namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_namespaced_pod_with_http_info(body, namespace_name, **kwargs)  # noqa: E501
            return data

    def add_namespaced_pod_with_http_info(self, body, namespace_name, **kwargs):  # noqa: E501
        """Create a Pod in a Namespace  # noqa: E501

        Create a Pod in a specific Namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespaced_pod_with_http_info(body, namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Pod body: Pod object that contains the key-value pairs to create a pod. **Note:** pod_name for good practices should contain only lowercase alphanumeric characters with or without '-' (required)
        :param str namespace_name: name of Namespace to create a Pod (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_namespaced_pod`")  # noqa: E501
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `add_namespaced_pod`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/pods', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_namespaced_resource_quota(self, body, namespace_name, **kwargs):  # noqa: E501
        """Create a ResourceQuota in a specific namespace  # noqa: E501

        Create a namespaced ResourceQuota Kubernetes-resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespaced_resource_quota(body, namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ResourceQuota body: Resourcequotas reserve cpu,memory and storage resources in the specified namespaces. (required)
        :param str namespace_name: name of namespace to create a ResourceQuota (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_namespaced_resource_quota_with_http_info(body, namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_namespaced_resource_quota_with_http_info(body, namespace_name, **kwargs)  # noqa: E501
            return data

    def add_namespaced_resource_quota_with_http_info(self, body, namespace_name, **kwargs):  # noqa: E501
        """Create a ResourceQuota in a specific namespace  # noqa: E501

        Create a namespaced ResourceQuota Kubernetes-resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespaced_resource_quota_with_http_info(body, namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ResourceQuota body: Resourcequotas reserve cpu,memory and storage resources in the specified namespaces. (required)
        :param str namespace_name: name of namespace to create a ResourceQuota (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_namespaced_resource_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_namespaced_resource_quota`")  # noqa: E501
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `add_namespaced_resource_quota`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/resourcequotas', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_namespaced_service(self, body, namespace_name, **kwargs):  # noqa: E501
        """Create a Service in a specific namespace  # noqa: E501

        Create a namespaced Service Kubernetes-resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespaced_service(body, namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Service body: Service object that needs to be added to expose Pod-resources in or out the cluster. **Note:** service_name must contain only lowercase alphanumeric characters or '-'.  The Service selector should match the label of the pod. The Service targetPort should match the container_port of the container inside the Pod. If service_type is ClusterIP, nodePort value must be set null in the service_port variable. Finally port_name is also optional. (required)
        :param str namespace_name: name of namespace to create a Service (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_namespaced_service_with_http_info(body, namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_namespaced_service_with_http_info(body, namespace_name, **kwargs)  # noqa: E501
            return data

    def add_namespaced_service_with_http_info(self, body, namespace_name, **kwargs):  # noqa: E501
        """Create a Service in a specific namespace  # noqa: E501

        Create a namespaced Service Kubernetes-resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespaced_service_with_http_info(body, namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Service body: Service object that needs to be added to expose Pod-resources in or out the cluster. **Note:** service_name must contain only lowercase alphanumeric characters or '-'.  The Service selector should match the label of the pod. The Service targetPort should match the container_port of the container inside the Pod. If service_type is ClusterIP, nodePort value must be set null in the service_port variable. Finally port_name is also optional. (required)
        :param str namespace_name: name of namespace to create a Service (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_namespaced_service`")  # noqa: E501
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `add_namespaced_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/services', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_namespaced_service_monitor(self, body, namespace_name, **kwargs):  # noqa: E501
        """Create a ServiceMonitor in a specific namespace  # noqa: E501

        Create a namespaced ServiceMonitor Custom Kubernetes-resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespaced_service_monitor(body, namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceMonitor body: ServiceMonitor Custom object that needs to be added to expose Pod-resources in the Prometheus server. **Note:** service_name must contain only lowercase alphanumeric characters or '-'.  The Service selector should match the label of the pod. The endpoints should match the Service port names. A release label must exist wit the value of the Prometheus name. If Prometheus is installed by a helm chart, the release value is the helm release name. (required)
        :param str namespace_name: name of namespace to create a ServiceMonitor (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_namespaced_service_monitor_with_http_info(body, namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_namespaced_service_monitor_with_http_info(body, namespace_name, **kwargs)  # noqa: E501
            return data

    def add_namespaced_service_monitor_with_http_info(self, body, namespace_name, **kwargs):  # noqa: E501
        """Create a ServiceMonitor in a specific namespace  # noqa: E501

        Create a namespaced ServiceMonitor Custom Kubernetes-resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_namespaced_service_monitor_with_http_info(body, namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceMonitor body: ServiceMonitor Custom object that needs to be added to expose Pod-resources in the Prometheus server. **Note:** service_name must contain only lowercase alphanumeric characters or '-'.  The Service selector should match the label of the pod. The endpoints should match the Service port names. A release label must exist wit the value of the Prometheus name. If Prometheus is installed by a helm chart, the release value is the helm release name. (required)
        :param str namespace_name: name of namespace to create a ServiceMonitor (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_namespaced_service_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_namespaced_service_monitor`")  # noqa: E501
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `add_namespaced_service_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/servicemonitors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_namespace(self, namespace_name, **kwargs):  # noqa: E501
        """Delete a Namespace  # noqa: E501

        Delete a Namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespace(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of Namespace to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_namespace_with_http_info(namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_namespace_with_http_info(namespace_name, **kwargs)  # noqa: E501
            return data

    def delete_namespace_with_http_info(self, namespace_name, **kwargs):  # noqa: E501
        """Delete a Namespace  # noqa: E501

        Delete a Namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespace_with_http_info(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of Namespace to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `delete_namespace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_namespaced_deployment(self, namespace_name, deployment_name, **kwargs):  # noqa: E501
        """Delete a namespaced Deployment  # noqa: E501

        Delete a namespaced Deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespaced_deployment(namespace_name, deployment_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_namespaced_deployment_with_http_info(namespace_name, deployment_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_namespaced_deployment_with_http_info(namespace_name, deployment_name, **kwargs)  # noqa: E501
            return data

    def delete_namespaced_deployment_with_http_info(self, namespace_name, deployment_name, **kwargs):  # noqa: E501
        """Delete a namespaced Deployment  # noqa: E501

        Delete a namespaced Deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespaced_deployment_with_http_info(namespace_name, deployment_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'deployment_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_deployment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `delete_namespaced_deployment`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `delete_namespaced_deployment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'deployment_name' in params:
            path_params['deployment_name'] = params['deployment_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/deployments/{deployment_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_namespaced_limit_range(self, namespace_name, limitrange_name, **kwargs):  # noqa: E501
        """Delete a namespaced LimitRange  # noqa: E501

        Delete a namespaced LimitRange  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespaced_limit_range(namespace_name, limitrange_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the LimitRange lives (required)
        :param str limitrange_name: name of LimitRange to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_namespaced_limit_range_with_http_info(namespace_name, limitrange_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_namespaced_limit_range_with_http_info(namespace_name, limitrange_name, **kwargs)  # noqa: E501
            return data

    def delete_namespaced_limit_range_with_http_info(self, namespace_name, limitrange_name, **kwargs):  # noqa: E501
        """Delete a namespaced LimitRange  # noqa: E501

        Delete a namespaced LimitRange  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespaced_limit_range_with_http_info(namespace_name, limitrange_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the LimitRange lives (required)
        :param str limitrange_name: name of LimitRange to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'limitrange_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_limit_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `delete_namespaced_limit_range`")  # noqa: E501
        # verify the required parameter 'limitrange_name' is set
        if ('limitrange_name' not in params or
                params['limitrange_name'] is None):
            raise ValueError("Missing the required parameter `limitrange_name` when calling `delete_namespaced_limit_range`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'limitrange_name' in params:
            path_params['limitrange_name'] = params['limitrange_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/limitranges/{limitrange_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_namespaced_pod(self, namespace_name, pod_name, **kwargs):  # noqa: E501
        """Delete a Pod from a specific Namespace  # noqa: E501

        Delete a namespaced Pod  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespaced_pod(namespace_name, pod_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of Namespace where the Pod lives (required)
        :param str pod_name: name of Pod to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_namespaced_pod_with_http_info(namespace_name, pod_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_namespaced_pod_with_http_info(namespace_name, pod_name, **kwargs)  # noqa: E501
            return data

    def delete_namespaced_pod_with_http_info(self, namespace_name, pod_name, **kwargs):  # noqa: E501
        """Delete a Pod from a specific Namespace  # noqa: E501

        Delete a namespaced Pod  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespaced_pod_with_http_info(namespace_name, pod_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of Namespace where the Pod lives (required)
        :param str pod_name: name of Pod to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'pod_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `delete_namespaced_pod`")  # noqa: E501
        # verify the required parameter 'pod_name' is set
        if ('pod_name' not in params or
                params['pod_name'] is None):
            raise ValueError("Missing the required parameter `pod_name` when calling `delete_namespaced_pod`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'pod_name' in params:
            path_params['pod_name'] = params['pod_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/pods/{pod_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_namespaced_resource_quota(self, namespace_name, resourcequota_name, **kwargs):  # noqa: E501
        """Delete a namespaced ResourceQuota  # noqa: E501

        Delete a namespaced ResourceQuota  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespaced_resource_quota(namespace_name, resourcequota_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the ResourceQuota lives (required)
        :param str resourcequota_name: name of ResourceQuota to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_namespaced_resource_quota_with_http_info(namespace_name, resourcequota_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_namespaced_resource_quota_with_http_info(namespace_name, resourcequota_name, **kwargs)  # noqa: E501
            return data

    def delete_namespaced_resource_quota_with_http_info(self, namespace_name, resourcequota_name, **kwargs):  # noqa: E501
        """Delete a namespaced ResourceQuota  # noqa: E501

        Delete a namespaced ResourceQuota  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespaced_resource_quota_with_http_info(namespace_name, resourcequota_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the ResourceQuota lives (required)
        :param str resourcequota_name: name of ResourceQuota to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'resourcequota_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_resource_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `delete_namespaced_resource_quota`")  # noqa: E501
        # verify the required parameter 'resourcequota_name' is set
        if ('resourcequota_name' not in params or
                params['resourcequota_name'] is None):
            raise ValueError("Missing the required parameter `resourcequota_name` when calling `delete_namespaced_resource_quota`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'resourcequota_name' in params:
            path_params['resourcequota_name'] = params['resourcequota_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/resourcequotas/{resourcequota_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_namespaced_service(self, namespace_name, service_name, **kwargs):  # noqa: E501
        """Delete a namespaced Service  # noqa: E501

        Delete a namespaced Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespaced_service(namespace_name, service_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Service lives (required)
        :param str service_name: name of Service to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_namespaced_service_with_http_info(namespace_name, service_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_namespaced_service_with_http_info(namespace_name, service_name, **kwargs)  # noqa: E501
            return data

    def delete_namespaced_service_with_http_info(self, namespace_name, service_name, **kwargs):  # noqa: E501
        """Delete a namespaced Service  # noqa: E501

        Delete a namespaced Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespaced_service_with_http_info(namespace_name, service_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Service lives (required)
        :param str service_name: name of Service to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'service_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `delete_namespaced_service`")  # noqa: E501
        # verify the required parameter 'service_name' is set
        if ('service_name' not in params or
                params['service_name'] is None):
            raise ValueError("Missing the required parameter `service_name` when calling `delete_namespaced_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'service_name' in params:
            path_params['service_name'] = params['service_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/services/{service_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_namespaced_service_monitor(self, namespace_name, servicemonitor_name, **kwargs):  # noqa: E501
        """Delete a namespaced ServiceMonitor  # noqa: E501

        Delete a namespaced ServiceMonitor  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespaced_service_monitor(namespace_name, servicemonitor_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the ServiceMonitor lives (required)
        :param str servicemonitor_name: name of ServiceMonitor to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_namespaced_service_monitor_with_http_info(namespace_name, servicemonitor_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_namespaced_service_monitor_with_http_info(namespace_name, servicemonitor_name, **kwargs)  # noqa: E501
            return data

    def delete_namespaced_service_monitor_with_http_info(self, namespace_name, servicemonitor_name, **kwargs):  # noqa: E501
        """Delete a namespaced ServiceMonitor  # noqa: E501

        Delete a namespaced ServiceMonitor  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_namespaced_service_monitor_with_http_info(namespace_name, servicemonitor_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the ServiceMonitor lives (required)
        :param str servicemonitor_name: name of ServiceMonitor to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'servicemonitor_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_service_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `delete_namespaced_service_monitor`")  # noqa: E501
        # verify the required parameter 'servicemonitor_name' is set
        if ('servicemonitor_name' not in params or
                params['servicemonitor_name'] is None):
            raise ValueError("Missing the required parameter `servicemonitor_name` when calling `delete_namespaced_service_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'servicemonitor_name' in params:
            path_params['servicemonitor_name'] = params['servicemonitor_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/servicemonitors/{servicemonitor_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_deployment(self, namespace_name, deployment_name, **kwargs):  # noqa: E501
        """Read a namespaced Deployment definition  # noqa: E501

        Returns the definition of a single Deployment by deployment_name in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_deployment(namespace_name, deployment_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of Namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to retrieve (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_deployment_with_http_info(namespace_name, deployment_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_deployment_with_http_info(namespace_name, deployment_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_deployment_with_http_info(self, namespace_name, deployment_name, **kwargs):  # noqa: E501
        """Read a namespaced Deployment definition  # noqa: E501

        Returns the definition of a single Deployment by deployment_name in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_deployment_with_http_info(namespace_name, deployment_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of Namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to retrieve (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'deployment_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_deployment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_deployment`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `get_namespaced_deployment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'deployment_name' in params:
            path_params['deployment_name'] = params['deployment_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/deployments/{deployment_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_deployment_resources(self, namespace_name, deployment_name, **kwargs):  # noqa: E501
        """Read namespaced Deployment resources  # noqa: E501

        Read resources in terms of CPU and memory of the specified Deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_deployment_resources(namespace_name, deployment_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to show the resources (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_deployment_resources_with_http_info(namespace_name, deployment_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_deployment_resources_with_http_info(namespace_name, deployment_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_deployment_resources_with_http_info(self, namespace_name, deployment_name, **kwargs):  # noqa: E501
        """Read namespaced Deployment resources  # noqa: E501

        Read resources in terms of CPU and memory of the specified Deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_deployment_resources_with_http_info(namespace_name, deployment_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to show the resources (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'deployment_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_deployment_resources" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_deployment_resources`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `get_namespaced_deployment_resources`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'deployment_name' in params:
            path_params['deployment_name'] = params['deployment_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/deployments/{deployment_name}/resources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_deployment_scale_replicas(self, namespace_name, deployment_name, **kwargs):  # noqa: E501
        """Read namespaced Deployment Scale replicas  # noqa: E501

        Read replicas of the Scale definition of the specified Deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_deployment_scale_replicas(namespace_name, deployment_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to show the number of replicas (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_deployment_scale_replicas_with_http_info(namespace_name, deployment_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_deployment_scale_replicas_with_http_info(namespace_name, deployment_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_deployment_scale_replicas_with_http_info(self, namespace_name, deployment_name, **kwargs):  # noqa: E501
        """Read namespaced Deployment Scale replicas  # noqa: E501

        Read replicas of the Scale definition of the specified Deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_deployment_scale_replicas_with_http_info(namespace_name, deployment_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to show the number of replicas (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'deployment_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_deployment_scale_replicas" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_deployment_scale_replicas`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `get_namespaced_deployment_scale_replicas`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'deployment_name' in params:
            path_params['deployment_name'] = params['deployment_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/deployments/{deployment_name}/replicas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_deployment_status(self, namespace_name, deployment_name, **kwargs):  # noqa: E501
        """Read namespaced Deployment status  # noqa: E501

        Read status of the specified Deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_deployment_status(namespace_name, deployment_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to show its status (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_deployment_status_with_http_info(namespace_name, deployment_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_deployment_status_with_http_info(namespace_name, deployment_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_deployment_status_with_http_info(self, namespace_name, deployment_name, **kwargs):  # noqa: E501
        """Read namespaced Deployment status  # noqa: E501

        Read status of the specified Deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_deployment_status_with_http_info(namespace_name, deployment_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to show its status (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'deployment_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_deployment_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_deployment_status`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `get_namespaced_deployment_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'deployment_name' in params:
            path_params['deployment_name'] = params['deployment_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/deployments/{deployment_name}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_deployments(self, namespace_name, **kwargs):  # noqa: E501
        """List Deployments of a specific Namespace  # noqa: E501

        Returns a list with the names of the Deployments of a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_deployments(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of Namespace to retrieve the Deployment-resources (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_deployments_with_http_info(namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_deployments_with_http_info(namespace_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_deployments_with_http_info(self, namespace_name, **kwargs):  # noqa: E501
        """List Deployments of a specific Namespace  # noqa: E501

        Returns a list with the names of the Deployments of a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_deployments_with_http_info(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of Namespace to retrieve the Deployment-resources (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_deployments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_deployments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/deployments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_limit_range(self, namespace_name, limitrange_name, **kwargs):  # noqa: E501
        """Read a namespaced LimitRange definition  # noqa: E501

        Returns the definition of a single LimitRange by limitrange_name in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_limit_range(namespace_name, limitrange_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the LimitRange lives (required)
        :param str limitrange_name: name of LimitRange to retrieve (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_limit_range_with_http_info(namespace_name, limitrange_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_limit_range_with_http_info(namespace_name, limitrange_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_limit_range_with_http_info(self, namespace_name, limitrange_name, **kwargs):  # noqa: E501
        """Read a namespaced LimitRange definition  # noqa: E501

        Returns the definition of a single LimitRange by limitrange_name in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_limit_range_with_http_info(namespace_name, limitrange_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the LimitRange lives (required)
        :param str limitrange_name: name of LimitRange to retrieve (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'limitrange_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_limit_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_limit_range`")  # noqa: E501
        # verify the required parameter 'limitrange_name' is set
        if ('limitrange_name' not in params or
                params['limitrange_name'] is None):
            raise ValueError("Missing the required parameter `limitrange_name` when calling `get_namespaced_limit_range`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'limitrange_name' in params:
            path_params['limitrange_name'] = params['limitrange_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/limitranges/{limitrange_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_limit_ranges(self, namespace_name, **kwargs):  # noqa: E501
        """List LimitRanges by namespace  # noqa: E501

        Returns a list with all the LimitRanges in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_limit_ranges(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace to retrieve the LimitRanges (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_limit_ranges_with_http_info(namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_limit_ranges_with_http_info(namespace_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_limit_ranges_with_http_info(self, namespace_name, **kwargs):  # noqa: E501
        """List LimitRanges by namespace  # noqa: E501

        Returns a list with all the LimitRanges in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_limit_ranges_with_http_info(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace to retrieve the LimitRanges (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_limit_ranges" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_limit_ranges`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/limitranges', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_pod_logs(self, namespace_name, pod_name, **kwargs):  # noqa: E501
        """Get logs of a namespaced Pod  # noqa: E501

        Get logs of a namespaced Pod  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_pod_logs(namespace_name, pod_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of Namespace where the pod lives (required)
        :param str pod_name: name of Pod to return the logs (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_pod_logs_with_http_info(namespace_name, pod_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_pod_logs_with_http_info(namespace_name, pod_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_pod_logs_with_http_info(self, namespace_name, pod_name, **kwargs):  # noqa: E501
        """Get logs of a namespaced Pod  # noqa: E501

        Get logs of a namespaced Pod  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_pod_logs_with_http_info(namespace_name, pod_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of Namespace where the pod lives (required)
        :param str pod_name: name of Pod to return the logs (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'pod_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_pod_logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_pod_logs`")  # noqa: E501
        # verify the required parameter 'pod_name' is set
        if ('pod_name' not in params or
                params['pod_name'] is None):
            raise ValueError("Missing the required parameter `pod_name` when calling `get_namespaced_pod_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'pod_name' in params:
            path_params['pod_name'] = params['pod_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/pods/{pod_name}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_pods(self, namespace_name, **kwargs):  # noqa: E501
        """List Pods by Namespace  # noqa: E501

        Returns a list with all the Pods in a specific Namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_pods(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of Namespace to retrieve the Pods (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_pods_with_http_info(namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_pods_with_http_info(namespace_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_pods_with_http_info(self, namespace_name, **kwargs):  # noqa: E501
        """List Pods by Namespace  # noqa: E501

        Returns a list with all the Pods in a specific Namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_pods_with_http_info(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of Namespace to retrieve the Pods (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_pods" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_pods`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/pods', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_resource_quota(self, namespace_name, resourcequota_name, **kwargs):  # noqa: E501
        """Read a namespaced ResourceQuota definition  # noqa: E501

        Returns the definition of a single ResourceQuota by resourcequota_name in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_resource_quota(namespace_name, resourcequota_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the ResourceQuota lives (required)
        :param str resourcequota_name: name of ResourceQuota to retrieve (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_resource_quota_with_http_info(namespace_name, resourcequota_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_resource_quota_with_http_info(namespace_name, resourcequota_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_resource_quota_with_http_info(self, namespace_name, resourcequota_name, **kwargs):  # noqa: E501
        """Read a namespaced ResourceQuota definition  # noqa: E501

        Returns the definition of a single ResourceQuota by resourcequota_name in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_resource_quota_with_http_info(namespace_name, resourcequota_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the ResourceQuota lives (required)
        :param str resourcequota_name: name of ResourceQuota to retrieve (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'resourcequota_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_resource_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_resource_quota`")  # noqa: E501
        # verify the required parameter 'resourcequota_name' is set
        if ('resourcequota_name' not in params or
                params['resourcequota_name'] is None):
            raise ValueError("Missing the required parameter `resourcequota_name` when calling `get_namespaced_resource_quota`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'resourcequota_name' in params:
            path_params['resourcequota_name'] = params['resourcequota_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/resourcequotas/{resourcequota_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_resource_quotas(self, namespace_name, **kwargs):  # noqa: E501
        """List ResourceQuotas by namespace  # noqa: E501

        Returns a list with all the ResourceQuotas in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_resource_quotas(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace to retrieve the ResourceQuotas (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_resource_quotas_with_http_info(namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_resource_quotas_with_http_info(namespace_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_resource_quotas_with_http_info(self, namespace_name, **kwargs):  # noqa: E501
        """List ResourceQuotas by namespace  # noqa: E501

        Returns a list with all the ResourceQuotas in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_resource_quotas_with_http_info(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace to retrieve the ResourceQuotas (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_resource_quotas" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_resource_quotas`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/resourcequotas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_service(self, namespace_name, service_name, **kwargs):  # noqa: E501
        """Read a namespaced Service definition  # noqa: E501

        Returns the definition of a single Service by service_name in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_service(namespace_name, service_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Service lives (required)
        :param str service_name: name of Service to retrieve (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_service_with_http_info(namespace_name, service_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_service_with_http_info(namespace_name, service_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_service_with_http_info(self, namespace_name, service_name, **kwargs):  # noqa: E501
        """Read a namespaced Service definition  # noqa: E501

        Returns the definition of a single Service by service_name in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_service_with_http_info(namespace_name, service_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Service lives (required)
        :param str service_name: name of Service to retrieve (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'service_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_service`")  # noqa: E501
        # verify the required parameter 'service_name' is set
        if ('service_name' not in params or
                params['service_name'] is None):
            raise ValueError("Missing the required parameter `service_name` when calling `get_namespaced_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'service_name' in params:
            path_params['service_name'] = params['service_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/services/{service_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_service_monitor(self, namespace_name, servicemonitor_name, **kwargs):  # noqa: E501
        """Read a namespaced ServiceMonitor definition  # noqa: E501

        Returns the definition of a single ServiceMonitor by servicemonitor_name in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_service_monitor(namespace_name, servicemonitor_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the ServiceMonitor lives (required)
        :param str servicemonitor_name: name of ServiceMonitor to retrieve (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_service_monitor_with_http_info(namespace_name, servicemonitor_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_service_monitor_with_http_info(namespace_name, servicemonitor_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_service_monitor_with_http_info(self, namespace_name, servicemonitor_name, **kwargs):  # noqa: E501
        """Read a namespaced ServiceMonitor definition  # noqa: E501

        Returns the definition of a single ServiceMonitor by servicemonitor_name in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_service_monitor_with_http_info(namespace_name, servicemonitor_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the ServiceMonitor lives (required)
        :param str servicemonitor_name: name of ServiceMonitor to retrieve (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'servicemonitor_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_service_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_service_monitor`")  # noqa: E501
        # verify the required parameter 'servicemonitor_name' is set
        if ('servicemonitor_name' not in params or
                params['servicemonitor_name'] is None):
            raise ValueError("Missing the required parameter `servicemonitor_name` when calling `get_namespaced_service_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'servicemonitor_name' in params:
            path_params['servicemonitor_name'] = params['servicemonitor_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/servicemonitors/{servicemonitor_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_service_monitors(self, namespace_name, **kwargs):  # noqa: E501
        """List ServiceMonitors by namespace  # noqa: E501

        Returns a list with all the ServiceMonitors in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_service_monitors(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace to retrieve the ServiceMonitors (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_service_monitors_with_http_info(namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_service_monitors_with_http_info(namespace_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_service_monitors_with_http_info(self, namespace_name, **kwargs):  # noqa: E501
        """List ServiceMonitors by namespace  # noqa: E501

        Returns a list with all the ServiceMonitors in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_service_monitors_with_http_info(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace to retrieve the ServiceMonitors (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_service_monitors" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_service_monitors`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/servicemonitors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_service_status(self, namespace_name, service_name, **kwargs):  # noqa: E501
        """Read namespaced Service status  # noqa: E501

        Read the status of the specified Service, like the Internal service IP, the External Service IP, the service ports and the service type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_service_status(namespace_name, service_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Service lives (required)
        :param str service_name: name of Service to show its status (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_service_status_with_http_info(namespace_name, service_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_service_status_with_http_info(namespace_name, service_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_service_status_with_http_info(self, namespace_name, service_name, **kwargs):  # noqa: E501
        """Read namespaced Service status  # noqa: E501

        Read the status of the specified Service, like the Internal service IP, the External Service IP, the service ports and the service type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_service_status_with_http_info(namespace_name, service_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace where the Service lives (required)
        :param str service_name: name of Service to show its status (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name', 'service_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_service_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_service_status`")  # noqa: E501
        # verify the required parameter 'service_name' is set
        if ('service_name' not in params or
                params['service_name'] is None):
            raise ValueError("Missing the required parameter `service_name` when calling `get_namespaced_service_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'service_name' in params:
            path_params['service_name'] = params['service_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/services/{service_name}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaced_services(self, namespace_name, **kwargs):  # noqa: E501
        """List Services by namespace  # noqa: E501

        Returns a list with all the Services in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_services(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace to retrieve the Services (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaced_services_with_http_info(namespace_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaced_services_with_http_info(namespace_name, **kwargs)  # noqa: E501
            return data

    def get_namespaced_services_with_http_info(self, namespace_name, **kwargs):  # noqa: E501
        """List Services by namespace  # noqa: E501

        Returns a list with all the Services in a specific namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaced_services_with_http_info(namespace_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str namespace_name: name of namespace to retrieve the Services (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaced_services" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `get_namespaced_services`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaces(self, **kwargs):  # noqa: E501
        """List all Namespaces  # noqa: E501

        Returns a list of all Namespaces in the cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaces(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaces_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaces_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_namespaces_with_http_info(self, **kwargs):  # noqa: E501
        """List all Namespaces  # noqa: E501

        Returns a list of all Namespaces in the cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaces_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaces" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scale_horizontal_namespaced_deployment(self, body, namespace_name, deployment_name, **kwargs):  # noqa: E501
        """Scale Horizontal a namespaced Deployment  # noqa: E501

        Scale either up or down the pods of a namespaced Deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scale_horizontal_namespaced_deployment(body, namespace_name, deployment_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScaleHorizontal body: Scale Horizontal object that needs to be added to a namespaced Deployment in order to scale up or down the pods (containers) it contains. **Note:** if replicas_number = 0, then we kill all the pods of the Deployment. (required)
        :param str namespace_name: name of namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to scale horizontically (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.scale_horizontal_namespaced_deployment_with_http_info(body, namespace_name, deployment_name, **kwargs)  # noqa: E501
        else:
            (data) = self.scale_horizontal_namespaced_deployment_with_http_info(body, namespace_name, deployment_name, **kwargs)  # noqa: E501
            return data

    def scale_horizontal_namespaced_deployment_with_http_info(self, body, namespace_name, deployment_name, **kwargs):  # noqa: E501
        """Scale Horizontal a namespaced Deployment  # noqa: E501

        Scale either up or down the pods of a namespaced Deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scale_horizontal_namespaced_deployment_with_http_info(body, namespace_name, deployment_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScaleHorizontal body: Scale Horizontal object that needs to be added to a namespaced Deployment in order to scale up or down the pods (containers) it contains. **Note:** if replicas_number = 0, then we kill all the pods of the Deployment. (required)
        :param str namespace_name: name of namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to scale horizontically (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'namespace_name', 'deployment_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scale_horizontal_namespaced_deployment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `scale_horizontal_namespaced_deployment`")  # noqa: E501
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `scale_horizontal_namespaced_deployment`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `scale_horizontal_namespaced_deployment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'deployment_name' in params:
            path_params['deployment_name'] = params['deployment_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/deployments/{deployment_name}/scaleHorizontal', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scale_vertical_namespaced_deployment(self, body, namespace_name, deployment_name, container_name, **kwargs):  # noqa: E501
        """Scale Vertical a namespaced Deployment  # noqa: E501

        Partialy update a namespaced Deployment - Vertical scaling. The update affects the pod-container resources such as CPU and memory.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scale_vertical_namespaced_deployment(body, namespace_name, deployment_name, container_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScaleVertical body: ScaleVertical object that needs to be added to a namespaced Deployment in the cluster to perform vertical scaling. **Note:** If you specify a limit for a resource, but do not specify any request, then Kubernetes copies the limit you specified and uses it as the requested value for the resource. (required)
        :param str namespace_name: name of namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to scale vertically (required)
        :param str container_name: name of container of the Deployment to scale vertically (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.scale_vertical_namespaced_deployment_with_http_info(body, namespace_name, deployment_name, container_name, **kwargs)  # noqa: E501
        else:
            (data) = self.scale_vertical_namespaced_deployment_with_http_info(body, namespace_name, deployment_name, container_name, **kwargs)  # noqa: E501
            return data

    def scale_vertical_namespaced_deployment_with_http_info(self, body, namespace_name, deployment_name, container_name, **kwargs):  # noqa: E501
        """Scale Vertical a namespaced Deployment  # noqa: E501

        Partialy update a namespaced Deployment - Vertical scaling. The update affects the pod-container resources such as CPU and memory.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scale_vertical_namespaced_deployment_with_http_info(body, namespace_name, deployment_name, container_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScaleVertical body: ScaleVertical object that needs to be added to a namespaced Deployment in the cluster to perform vertical scaling. **Note:** If you specify a limit for a resource, but do not specify any request, then Kubernetes copies the limit you specified and uses it as the requested value for the resource. (required)
        :param str namespace_name: name of namespace where the Deployment lives (required)
        :param str deployment_name: name of Deployment to scale vertically (required)
        :param str container_name: name of container of the Deployment to scale vertically (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'namespace_name', 'deployment_name', 'container_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scale_vertical_namespaced_deployment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `scale_vertical_namespaced_deployment`")  # noqa: E501
        # verify the required parameter 'namespace_name' is set
        if ('namespace_name' not in params or
                params['namespace_name'] is None):
            raise ValueError("Missing the required parameter `namespace_name` when calling `scale_vertical_namespaced_deployment`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `scale_vertical_namespaced_deployment`")  # noqa: E501
        # verify the required parameter 'container_name' is set
        if ('container_name' not in params or
                params['container_name'] is None):
            raise ValueError("Missing the required parameter `container_name` when calling `scale_vertical_namespaced_deployment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'namespace_name' in params:
            path_params['namespace_name'] = params['namespace_name']  # noqa: E501
        if 'deployment_name' in params:
            path_params['deployment_name'] = params['deployment_name']  # noqa: E501
        if 'container_name' in params:
            path_params['container_name'] = params['container_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/namespaces/{namespace_name}/deployments/{deployment_name}/{container_name}/scaleVertical', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
